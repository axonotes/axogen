# Simple App Example

:::warning Documentation Status

The docs are currently not up to date as I'm focused on stabilizing core
features. For the most current information, you might need to check the source
code on GitHub or the examples in this blog post. Proper documentation will come
once the API is more stable!

:::

Look, you're building a simple Node.js app. Maybe it's an Express API, maybe
it's a CLI tool, doesn't matter. Point is, you need some basic configuration -
database URL, port number, API keys.

The usual approach? Create a `.env` file, hope you remember to update it when
things change, and pray you don't accidentally commit your secrets to git.

There's gotta be a better way. Spoiler: there is.

## The Problem

You've probably done this dance before:

1. Create `.env` file
2. Add some variables
3. Load them with `dotenv`
4. Forget what format you used
5. Wonder if `PORT` should be a string or number
6. Accidentally commit secrets (oops)
7. Have different formats across different projects

It's not the end of the world, but it's annoying. And when you add more config
files later (JSON for your frontend, YAML for Docker), keeping them in sync
becomes a pain.

## What We're Building

A simple Express.js API that needs:

- Database connection string
- Server port
- Environment (dev/staging/prod)
- API key for some external service

Nothing fancy. Just the basics most apps need.

## Project Structure

```
simple-app/
├── axogen.config.ts       # Our config definition
├── .env.axogen            # Actual values (don't commit this!)
├── .env                   # Generated file (also don't commit this!)
├── server.js              # Our simple API
└── package.json
```

## Step 1: Install Axogen

```bash npm2yarn
npm install @axonotes/axogen
```

## Step 2: Create Your Config Definition

Create `axogen.config.ts`:

```typescript
import {z, defineConfig, createTypedEnv} from "@axonotes/axogen";

// Define what environment variables you need
const env = createTypedEnv({
    DATABASE_URL: z.url(),
    PORT: z.coerce.number().default(3000),
    NODE_ENV: z
        .enum(["development", "staging", "production"])
        .default("development"),
    API_KEY: z.string().min(10, "API key should be at least 10 characters"),
});

export default defineConfig({
    targets: {
        // Generate a .env file for our Node.js app
        app: {
            path: ".env",
            type: "env",
            variables: {
                DATABASE_URL: env.DATABASE_URL,
                PORT: env.PORT,
                NODE_ENV: env.NODE_ENV,
                API_KEY: env.API_KEY,
            },
        },
    },
    commands: {
        // Simple commands to replace package.json scripts
        start: "node server.js",
        dev: "nodemon server.js",
    },
});
```

## Step 3: Set Your Actual Values

Create `.env.axogen` with your real values:

```bash
DATABASE_URL=postgresql://localhost:5432/myapp
PORT=3000
NODE_ENV=development
API_KEY=your-secret-api-key-here
```

**Important:** Add `.env.axogen` to your `.gitignore`! This file contains your
secrets.

```gitignore
.env
.env.axogen
node_modules/
```

## Step 4: Generate Your Config

```bash
axogen generate
```

This creates a `.env` file with your validated values:

```bash
# Generated by axogen - do not edit manually
# Generated at 2025-07-20T00:00:00.000Z
# Target: .env

META_FORMAT=env
META_GENERATED_AT=2025-07-20T00:00:00.000Z
META_GENERATOR=axogen
META_TARGET_PATH=.env
META_WARNING="This file was generated automatically - do not edit manually"

API_KEY=your-secret-api-key-here
DATABASE_URL=postgresql://localhost:5432/myapp
NODE_ENV=development
PORT=3000
```

## Step 5: Use It In Your App

Your `server.js` works exactly like before:

```javascript
require("dotenv").config();

const express = require("express");
const app = express();

const PORT = process.env.PORT;
const DATABASE_URL = process.env.DATABASE_URL;

app.get("/", (req, res) => {
    res.json({
        message: "Hello World!",
        env: process.env.NODE_ENV,
        port: PORT,
    });
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```

## Step 6: Run Your App

Instead of `npm start`, use Axogen:

```bash
axogen run start
```

## What Just Happened?

1. **Type Safety**: Your environment variables are validated. Try setting
   `PORT=not-a-number` in `.env.axogen` and watch Axogen yell at you.

2. **Single Source of Truth**: Change a value in `.env.axogen`, run
   `axogen generate`, and your app config updates.

3. **No More Guessing**: The schema in your config tells you exactly what
   variables are required and what format they should be.

4. **Better Commands**: Replace your package.json scripts with typed commands
   that have access to your config.

## Try It Out

Change your port in `.env.axogen`:

```bash
PORT=4000
```

Run `axogen generate` and check your `.env` file. The port is updated. Your app
will use the new port when you restart it.

Try breaking something:

```bash
DATABASE_URL=not-a-valid-url
```

Run `axogen generate` and watch it fail with a helpful error message. This
catches config problems before your app even starts.

## What's Next?

This is just the beginning. You can:

- Generate multiple formats (JSON, YAML) from the same config
- Use templates for complex file generation
- Add more sophisticated commands with options
- Handle multiple environments cleanly

But for now, you've got type-safe environment variables and you'll never
accidentally deploy with the wrong config again.

Check out the [Multi-Format Example](multi-format.md) to see how to generate
different file types from the same source data.

## Common Variations

**Want different environments?** Use TypeScript's flexibility:

```typescript
const env = createTypedEnv({
    DATABASE_URL: z
        .string()
        .url()
        .default(
            process.env.NODE_ENV === "production"
                ? "postgresql://prod-server/db"
                : "postgresql://localhost:5432/dev-db"
        ),
    // ... other variables
});
```

**Want different file locations?** Change the path:

```typescript
export default defineConfig({
    targets: {
        app: {
            path: "config/.env", // generates config/.env instead
            type: "env",
            variables: env,
        },
    },
});
```

The point is: start simple, grow as needed. That's the Axogen way.
