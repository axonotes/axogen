# Multi-Format Example

:::warning Documentation Status

The docs are currently not up to date as I'm focused on stabilizing core
features. For the most current information, you might need to check the source
code on GitHub or the examples in this blog post. Proper documentation will come
once the API is more stable!

:::

_One config, many outputs - because keeping files in sync manually is pain_

## The Problem

You've got a simple app that needs the same configuration data in different
formats. Your backend reads a `.env` file, your frontend build process needs a
JSON config, and your deployment pipeline uses a YAML file.

Every time you change the database URL or add an API endpoint, you're updating
three different files. Miss one? Your staging environment mysteriously breaks
and you spend 20 minutes figuring out why.

Sound familiar? Let's fix it.

## The Project

Here's what we're working with - a typical setup where the same data lives in
multiple formats:

```
my-app/
├── .env                    # Backend environment variables
├── config.json             # Frontend build configuration
└── deploy.yaml             # Deployment configuration
```

## The Axogen Way

Instead of maintaining three separate files, we define everything once:

```typescript
// axogen.config.ts
import {z, defineConfig, createTypedEnv} from "@axonotes/axogen";

const env = createTypedEnv({
    DATABASE_URL: z.url(),
    API_URL: z.url(),
    PORT: z.coerce.number().default(3000),
    NODE_ENV: z
        .enum(["development", "staging", "production"])
        .default("development"),
    JWT_SECRET: z.string().min(32),
});

export default defineConfig({
    targets: {
        // Backend .env file
        backend: {
            path: ".env",
            type: "env",
            variables: {
                DATABASE_URL: env.DATABASE_URL,
                PORT: env.PORT,
                NODE_ENV: env.NODE_ENV,
                JWT_SECRET: env.JWT_SECRET,
            },
        },

        // Frontend config.json
        frontend: {
            path: "config.json",
            type: "json",
            variables: {
                api: {
                    url: env.API_URL,
                    timeout: 5000,
                },
                environment: env.NODE_ENV,
                features: {
                    analytics: env.NODE_ENV === "production",
                    debugMode: env.NODE_ENV === "development",
                },
            },
        },

        // Deployment YAML
        deployment: {
            path: "deploy.yaml",
            type: "yaml",
            variables: {
                apiVersion: "v1",
                kind: "ConfigMap",
                metadata: {
                    name: "app-config",
                },
                data: {
                    DATABASE_URL: env.DATABASE_URL,
                    API_URL: env.API_URL,
                    NODE_ENV: env.NODE_ENV,
                    PORT: env.PORT.toString(),
                },
            },
        },
    },
});
```

Set your actual values in `.env.axogen`:

```bash
DATABASE_URL=postgresql://localhost:5432/myapp
API_URL=http://localhost:3000
PORT=3000
NODE_ENV=development
JWT_SECRET=your-super-secret-jwt-key-here-make-it-long
```

## Generate Everything

One command, three files:

```bash
axogen generate
```

## What Gets Generated

**`.env`** (for your backend):

```bash
# Generated by axogen - do not edit manually
# Generated at 2025-07-20T00:00:00.000Z
# Target: .env

META_FORMAT=env
META_GENERATED_AT=2025-07-20T00:00:00.000Z
META_GENERATOR=axogen
META_TARGET_PATH=.env
META_WARNING="This file was generated automatically - do not edit manually"

DATABASE_URL=postgresql://localhost:5432/myapp
JWT_SECRET=your-super-secret-jwt-key-here-make-it-long
NODE_ENV=development
PORT=3000
```

**`config.json`** (for your frontend build):

```json
{
    "_meta": {
        "generator": "axogen",
        "generated_at": "2025-07-20T00:00:00.000Z",
        "warning": "This file was generated automatically - do not edit manually",
        "target_path": "config.json",
        "format": "json"
    },
    "api": {
        "url": "http://localhost:3000",
        "timeout": 5000
    },
    "environment": "development",
    "features": {
        "analytics": false,
        "debugMode": true
    }
}
```

**`deploy.yaml`** (for your deployment):

```yaml
# Generated by axogen - do not edit manually
# Generated at 2025-07-20T00:00:00.000Z
# Target: deploy.yaml
_meta:
    generator: axogen
    generated_at: "2025-07-20T00:00:00.000Z"
    warning: This file was generated automatically - do not edit manually
    target_path: deploy.yaml
    format: yaml
apiVersion: v1
kind: ConfigMap
metadata:
    name: app-config
data:
    DATABASE_URL: postgresql://localhost:5432/myapp
    API_URL: http://localhost:3000
    NODE_ENV: development
    PORT: "3000"
```

## The Payoff

Now when you need to change your database URL, you update **one file**
(`.env.axogen`), run `axogen generate`, and all three formats are updated with
the new value.

No more "why is staging broken?" No more hunting through multiple files. No more
copy-paste errors.

Want to add a new API endpoint? Add it to the config once, and it appears in all
the right places automatically.

## Common Variations

**Different environments?** Use TypeScript's power:

```typescript
const env = createTypedEnv({
    DATABASE_URL: z.string().url(),
    NODE_ENV: z
        .enum(["development", "staging", "production"])
        .default("development"),
});

// In your config
export default defineConfig({
    targets: {
        backend: {
            // path and type as before
            variables: {
                DATABASE_URL:
                    env.NODE_ENV === "production"
                        ? env.DATABASE_URL
                        : "postgresql://localhost:5432/dev_db",
                // ... other variables
            },
        },
    },
});
```

**Need TOML for your Rust service?** Just add another target:

```typescript
export default defineConfig({
    targets: {
        // Other targets...
        rust_config: {
            path: "config.toml",
            type: "toml",
            variables: {
                database_url: env.DATABASE_URL,
                port: env.PORT,
            },
        },
    },
});
```

**Want to validate generated files before deployment?** Use dry-run:

```bash
axogen generate --dry-run  # See what would be generated
```

That's it. One source of truth, multiple outputs, zero manual syncing. Your
future self will thank you.
