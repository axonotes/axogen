import type {EnvTarget} from "../types";

export class EnvGenerator {
    /** Generate .env file content from target configuration */
    generate(target: EnvTarget): string {
        const lines: string[] = [];

        // Add header comments
        const headerLines = [
            "# Generated by axogen - do not edit manually",
            `# Generated at ${new Date().toISOString()}`,
            `# Target: ${target.path}`,
            "",
        ];
        lines.push(...headerLines);

        const flattenSortAndAppend = (obj: Record<string, any>) => {
            const flattened = this.flattenVariables(obj);
            const sortedKeys = Object.keys(flattened).sort();
            for (const key of sortedKeys) {
                const value = flattened[key];
                const envLine = this.formatEnvVariable(key, value);
                if (envLine) {
                    lines.push(envLine);
                }
            }
        };

        // Add metadata as env variables
        const metaVariables = this.createMetaVariables(target);
        flattenSortAndAppend(metaVariables);

        lines.push(""); // Add a blank line after metadata

        // Process variables to handle complex types
        const processedVariables = this.processVariables(target.variables);
        flattenSortAndAppend(processedVariables);

        return lines.join("\n");
    }

    /** Create metadata variables */
    private createMetaVariables(target: EnvTarget): Record<string, any> {
        return {
            _meta: {
                generator: "axogen",
                generated_at: new Date().toISOString(),
                warning:
                    "This file was generated automatically - do not edit manually",
                target_path: target.path,
                format: "env",
            },
        };
    }

    /** Process variables to handle non-primitive types */
    private processVariables(
        variables: Record<string, any>
    ): Record<string, any> {
        const seen = new WeakSet();
        return this.processValue(variables, seen);
    }

    /** Recursively process values to handle complex types */
    private processValue(value: any, seen: WeakSet<object>): any {
        // Handle null and undefined
        if (value === null || value === undefined) {
            return value;
        }

        // Handle primitives
        if (
            typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean"
        ) {
            return value;
        }

        // Handle BigInt
        if (typeof value === "bigint") {
            return value.toString();
        }

        // Handle Symbol
        if (typeof value === "symbol") {
            return `Symbol(${value.description || ""})`;
        }

        // Handle functions
        if (typeof value === "function") {
            return `[Function: ${value.name || "anonymous"}]`;
        }

        // Handle objects and arrays
        if (typeof value === "object") {
            // Check for circular references
            if (seen.has(value)) {
                return "[Circular Reference]";
            }
            seen.add(value);

            try {
                // Handle arrays
                if (Array.isArray(value)) {
                    return value.map((item) => this.processValue(item, seen));
                }

                // Handle Date objects
                if (value instanceof Date) {
                    return value.toISOString();
                }

                // Handle RegExp
                if (value instanceof RegExp) {
                    return `/${value.source}/${value.flags}`;
                }

                // Handle Error objects
                if (value instanceof Error) {
                    return `${value.name}: ${value.message}`;
                }

                // Handle Map
                if (value instanceof Map) {
                    const obj: Record<string, any> = {};
                    for (const [k, v] of value.entries()) {
                        const key = typeof k === "string" ? k : String(k);
                        obj[key] = this.processValue(v, seen);
                    }
                    return obj;
                }

                // Handle Set
                if (value instanceof Set) {
                    return Array.from(value).map((v) =>
                        this.processValue(v, seen)
                    );
                }

                // Handle URL
                if (value instanceof URL) {
                    return value.toString();
                }

                // Handle Buffer (Node.js)
                if (typeof Buffer !== "undefined" && value instanceof Buffer) {
                    return value.toString("base64");
                }

                // Handle ArrayBuffer
                if (value instanceof ArrayBuffer) {
                    return "[Binary Data]";
                }

                // Handle typed arrays
                if (ArrayBuffer.isView(value)) {
                    return Array.from(value as any);
                }

                // Handle plain objects
                const processed: Record<string, any> = {};
                for (const [key, val] of Object.entries(value)) {
                    try {
                        processed[key] = this.processValue(val, seen);
                    } catch (error) {
                        processed[key] = `[Error: ${error}]`;
                    }
                }
                return processed;
            } finally {
                seen.delete(value);
            }
        }

        // Fallback for any other types
        return String(value);
    }

    /** Flatten nested objects and arrays into underscore-separated uppercase keys */
    private flattenVariables(
        obj: Record<string, any>,
        prefix: string = "",
        separator: string = "_"
    ): Record<string, any> {
        const flattened: Record<string, any> = {};

        for (const [key, value] of Object.entries(obj)) {
            // Convert key to uppercase and sanitize
            const sanitizedKey = this.sanitizeKey(key);
            const newKey = prefix
                ? `${prefix}${separator}${sanitizedKey}`
                : sanitizedKey;

            if (value === null || value === undefined) {
                flattened[newKey] = value;
            } else if (Array.isArray(value)) {
                // Flatten arrays with indexed keys
                value.forEach((item, index) => {
                    if (typeof item === "object" && item !== null) {
                        // Recursively flatten object items
                        const nested = this.flattenVariables(
                            {[index]: item},
                            newKey,
                            separator
                        );
                        Object.assign(flattened, nested);
                    } else {
                        flattened[`${newKey}${separator}${index}`] = item;
                    }
                });
                // Also add array length for convenience
                flattened[`${newKey}${separator}LENGTH`] = value.length;
            } else if (typeof value === "object") {
                // Recursively flatten nested objects
                const nested = this.flattenVariables(value, newKey, separator);
                Object.assign(flattened, nested);
            } else {
                flattened[newKey] = value;
            }
        }

        return flattened;
    }

    /** Sanitize and format key for environment variable naming */
    private sanitizeKey(key: string): string {
        return (
            key
                // Convert to uppercase
                .toUpperCase()
                // Replace non-alphanumeric characters with underscores
                .replace(/[^A-Z0-9]/g, "_")
                // Remove consecutive underscores
                .replace(/_+/g, "_")
                // Remove leading/trailing underscores
                .replace(/^_+|_+$/g, "")
        );
    }

    /** Format a single environment variable */
    private formatEnvVariable(key: string, value: any): string | null {
        // Skip undefined values
        if (value === undefined) {
            return null;
        }

        // Convert value to string (primitives only now since we've processed)
        let stringValue: string;

        if (value === null) {
            stringValue = "";
        } else if (typeof value === "boolean") {
            stringValue = value ? "true" : "false";
        } else if (typeof value === "number") {
            stringValue = value.toString();
        } else if (typeof value === "string") {
            stringValue = value;
        } else {
            // Fallback for any remaining complex types
            stringValue = String(value);
        }

        // Escape quotes in values
        const escapedValue = this.escapeEnvValue(stringValue);

        return `${key}=${escapedValue}`;
    }

    /** Escape environment variable values that contain special characters */
    private escapeEnvValue(value: string): string {
        // If value contains spaces, quotes, or special chars, wrap in quotes
        if (this.needsQuoting(value)) {
            // Escape existing double quotes and backslashes
            const escaped = value
                .replace(/\\/g, "\\\\") // Escape backslashes first
                .replace(/"/g, '\\"') // Then escape quotes
                .replace(/\n/g, "\\n") // Escape newlines
                .replace(/\r/g, "\\r") // Escape carriage returns
                .replace(/\t/g, "\\t"); // Escape tabs
            return `"${escaped}"`;
        }

        return value;
    }

    /** Check if a value needs to be quoted */
    private needsQuoting(value: string): boolean {
        // Empty string needs quotes
        if (value === "") {
            return true;
        }

        // Check for characters that require quoting
        return /[\s"'`${}\\#\n\r\t]/.test(value);
    }
}
