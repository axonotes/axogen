import * as yaml from "js-yaml";
import type {YamlTarget} from "../types";

export class YamlGenerator {
    /** Generate YAML file content from target configuration */
    generate(target: YamlTarget): string {
        const options = {
            indent: 2,
            lineWidth: 80,
            noRefs: false,
            ...target.options,
        };

        try {
            // Process variables
            const processedVariables = this.processVariables(target.variables);

            // Add metadata header
            const dataWithMeta = this.addMetadata(processedVariables, target);

            // Generate YAML using js-yaml
            const yamlContent = yaml.dump(dataWithMeta, {
                indent: options.indent,
                lineWidth: options.lineWidth,
                noRefs: options.noRefs,
                sortKeys: false, // Preserve order (meta first)
                quotingType: '"',
                forceQuotes: false,
            });

            // Add header comments
            const headerLines = [
                "# Generated by axogen - do not edit manually",
                `# Generated at ${new Date().toISOString()}`,
                `# Target: ${target.path}`,
                "",
            ];

            return headerLines.join("\n") + yamlContent;
        } catch (error) {
            throw new Error(
                `Failed to generate YAML for target: ${
                    error instanceof Error ? error.message : String(error)
                }`
            );
        }
    }

    /** Add metadata to the YAML output */
    private addMetadata(variables: any, target: YamlTarget): any {
        return {
            _meta: {
                generator: "axogen",
                generated_at: new Date().toISOString(),
                warning:
                    "This file was generated automatically - do not edit manually",
                target_path: target.path,
                format: "yaml",
            },
            ...variables,
        };
    }

    /** Process variables to handle non-YAML-serializable types */
    private processVariables(variables: Record<string, any>): any {
        const seen = new WeakSet();
        return this.processValue(variables, seen);
    }

    /** Recursively process values to handle non-YAML types */
    private processValue(value: any, seen: WeakSet<object>): any {
        // Handle null and undefined
        if (value === null || value === undefined) {
            return value;
        }

        // Handle primitives that YAML supports natively
        if (
            typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean"
        ) {
            return value;
        }

        // Handle BigInt
        if (typeof value === "bigint") {
            return value.toString() + "n";
        }

        // Handle Symbol
        if (typeof value === "symbol") {
            return `Symbol(${value.description || ""})`;
        }

        // Handle functions
        if (typeof value === "function") {
            return `[Function: ${value.name || "anonymous"}]`;
        }

        // Handle objects and arrays
        if (typeof value === "object") {
            // Check for circular references
            if (seen.has(value)) {
                return "[Circular Reference]";
            }
            seen.add(value);

            try {
                // Handle arrays
                if (Array.isArray(value)) {
                    return value.map((item) => this.processValue(item, seen));
                }

                // Handle Date objects
                if (value instanceof Date) {
                    return value.toISOString();
                }

                // Handle RegExp
                if (value instanceof RegExp) {
                    return {
                        _type: "RegExp",
                        source: value.source,
                        flags: value.flags,
                    };
                }

                // Handle Error objects
                if (value instanceof Error) {
                    return {
                        _type: "Error",
                        name: value.name,
                        message: value.message,
                        stack: value.stack,
                    };
                }

                // Handle Map
                if (value instanceof Map) {
                    return {
                        _type: "Map",
                        entries: Array.from(value.entries()).map(([k, v]) => ({
                            key: this.processValue(k, seen),
                            value: this.processValue(v, seen),
                        })),
                    };
                }

                // Handle Set
                if (value instanceof Set) {
                    return {
                        _type: "Set",
                        values: Array.from(value).map((v) =>
                            this.processValue(v, seen)
                        ),
                    };
                }

                // Handle URL
                if (value instanceof URL) {
                    return value.toString();
                }

                // Handle Buffer (Node.js)
                if (typeof Buffer !== "undefined" && value instanceof Buffer) {
                    return {
                        _type: "Buffer",
                        data: value.toString("base64"),
                        encoding: "base64",
                    };
                }

                // Handle plain objects
                const processed: Record<string, any> = {};
                for (const [key, val] of Object.entries(value)) {
                    try {
                        processed[key] = this.processValue(val, seen);
                    } catch (error) {
                        processed[key] = `[Error: ${error}]`;
                    }
                }
                return processed;
            } finally {
                seen.delete(value);
            }
        }

        // Fallback
        return String(value);
    }
}
