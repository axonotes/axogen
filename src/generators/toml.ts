import * as TOML from "@iarna/toml";
import type {ZodTomlTarget} from "../config/types";

export class TomlGenerator {
    /** Generate TOML file content from target configuration */
    generate(target: ZodTomlTarget): string {
        try {
            // Process variables to handle non-TOML-serializable types
            const processedVariables = this.processVariables(target.variables);

            let data: Record<string, any>;
            if (target.generate_meta) {
                // Add metadata header fields
                data = this.addMetadata(processedVariables, target);
            } else {
                data = processedVariables;
            }

            // Generate TOML using the library
            const tomlContent = TOML.stringify(data);

            // Add header comments
            const headerLines = [
                "# Generated by axogen - do not edit manually",
                `# Generated at ${new Date().toISOString()}`,
                `# Target: ${target.path}`,
                "",
            ];

            return headerLines.join("\n") + tomlContent;
        } catch (error) {
            throw new Error(
                `Failed to generate TOML for target: ${
                    error instanceof Error ? error.message : String(error)
                }`
            );
        }
    }

    /** Add metadata to the TOML output */
    private addMetadata(variables: any, target: ZodTomlTarget): any {
        return {
            _meta: {
                generator: "axogen",
                generated_at: new Date().toISOString(),
                warning:
                    "This file was generated automatically - do not edit manually",
                target_path: target.path,
                format: "toml",
            },
            ...variables,
        };
    }

    /** Process variables to handle non-TOML-serializable types */
    private processVariables(variables: Record<string, any>): any {
        const seen = new WeakSet();
        return this.processValue(variables, seen);
    }

    /** Recursively process values to handle non-TOML types */
    private processValue(value: any, seen: WeakSet<object>): any {
        // Handle null - TOML doesn't support null, so we skip it
        if (value === null || value === undefined) {
            return undefined; // This will be omitted from TOML output
        }

        // Handle primitives that TOML supports natively
        if (
            typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean"
        ) {
            return value;
        }

        // Handle BigInt
        if (typeof value === "bigint") {
            // TOML supports integers, but BigInt might be too large
            try {
                return Number(value);
            } catch {
                return value.toString() + "n";
            }
        }

        // Handle Symbol
        if (typeof value === "symbol") {
            return `Symbol(${value.description || ""})`;
        }

        // Handle functions
        if (typeof value === "function") {
            return `[Function: ${value.name || "anonymous"}]`;
        }

        // Handle objects and arrays
        if (typeof value === "object") {
            // Check for circular references
            if (seen.has(value)) {
                return "[Circular Reference]";
            }
            seen.add(value);

            try {
                // Handle arrays
                if (Array.isArray(value)) {
                    const processedArray = value.map((item) =>
                        this.processValue(item, seen)
                    );

                    // TOML requires arrays to be homogeneous
                    if (processedArray.length === 0) {
                        return [];
                    }

                    // Check if all items are the same type
                    const firstType = typeof processedArray[0];
                    const isHomogeneous = processedArray.every((item) => {
                        if (item === null || item === undefined) return false;
                        return typeof item === firstType;
                    });

                    if (!isHomogeneous) {
                        // Convert mixed arrays to strings for TOML compatibility
                        return processedArray.map((item) => String(item));
                    }

                    return processedArray.filter((item) => item !== undefined);
                }

                // Handle Date objects
                if (value instanceof Date) {
                    return value; // TOML supports dates natively
                }

                // Handle RegExp
                if (value instanceof RegExp) {
                    return {
                        _type: "RegExp",
                        source: value.source,
                        flags: value.flags,
                    };
                }

                // Handle Error objects
                if (value instanceof Error) {
                    return {
                        _type: "Error",
                        name: value.name,
                        message: value.message,
                        // Skip stack as it's usually too verbose for TOML
                    };
                }

                // Handle Map
                if (value instanceof Map) {
                    // Convert Map to regular object for TOML
                    const obj: Record<string, any> = {};
                    for (const [k, v] of value.entries()) {
                        const key = typeof k === "string" ? k : String(k);
                        obj[key] = this.processValue(v, seen);
                    }
                    return {
                        _type: "Map",
                        data: obj,
                    };
                }

                // Handle Set
                if (value instanceof Set) {
                    return {
                        _type: "Set",
                        values: Array.from(value).map((v) =>
                            this.processValue(v, seen)
                        ),
                    };
                }

                // Handle URL
                if (value instanceof URL) {
                    return value.toString();
                }

                // Handle Buffer (Node.js)
                if (typeof Buffer !== "undefined" && value instanceof Buffer) {
                    return {
                        _type: "Buffer",
                        data: value.toString("base64"),
                        encoding: "base64",
                    };
                }

                // Handle plain objects
                const processed: Record<string, any> = {};
                for (const [key, val] of Object.entries(value)) {
                    try {
                        const processedVal = this.processValue(val, seen);
                        if (processedVal !== undefined) {
                            // Ensure TOML-compatible key names
                            const tomlKey = this.sanitizeKey(key);
                            processed[tomlKey] = processedVal;
                        }
                    } catch (error) {
                        processed[key] = `[Error: ${error}]`;
                    }
                }
                return processed;
            } finally {
                seen.delete(value);
            }
        }

        // Fallback - convert to string
        return String(value);
    }

    /** Sanitize keys to be TOML-compatible */
    private sanitizeKey(key: string): string {
        // TOML bare keys can only contain A-Z, a-z, 0-9, -, _
        // If the key contains other characters, it will be quoted automatically by the library
        return key;
    }
}
